# Compose åµŒå¥—æ»šåŠ¨å†²çªå®Œå…¨æŒ‡å—

> ä»é›¶å¼€å§‹ç†è§£å¹¶è§£å†³ Compose ä¸­çš„åµŒå¥—æ»šåŠ¨å†²çªé—®é¢˜

---

## ğŸ“– ç›®å½•

1. [é—®é¢˜èƒŒæ™¯](#é—®é¢˜èƒŒæ™¯)
2. [é—®é¢˜æ˜¯æ€ä¹ˆå¯¼è‡´çš„](#é—®é¢˜æ˜¯æ€ä¹ˆå¯¼è‡´çš„)
3. [åŸç†æ·±åº¦è§£æ](#åŸç†æ·±åº¦è§£æ)
4. [è§£å†³æ€è·¯](#è§£å†³æ€è·¯)
5. [æœ€ä½³å®è·µæ ‡å‡†](#æœ€ä½³å®è·µæ ‡å‡†)
6. [é‡åˆ°ç±»ä¼¼é—®é¢˜çš„æ’æŸ¥æŒ‡å—](#é‡åˆ°ç±»ä¼¼é—®é¢˜çš„æ’æŸ¥æŒ‡å—)

---

## é—®é¢˜èƒŒæ™¯

### åœºæ™¯æè¿°

æˆ‘ä»¬æœ‰ä¸€ä¸ª K çº¿å›¾ç»„ä»¶ï¼ˆKLineChartï¼‰ï¼Œå®ƒæ”¯æŒï¼š
- **æ°´å¹³æ»‘åŠ¨**ï¼šæµè§ˆå†å² K çº¿æ•°æ®
- **åŒæŒ‡ç¼©æ”¾**ï¼šè°ƒæ•´ K çº¿çš„æ—¶é—´ç²’åº¦
- **é•¿æŒ‰**ï¼šæ˜¾ç¤ºåå­—å…‰æ ‡æŸ¥çœ‹è¯¦æƒ…

è¿™ä¸ªç»„ä»¶è¢«åµŒå¥—åœ¨ä¸€ä¸ªå¯å‚ç›´æ»šåŠ¨çš„é¡µé¢ä¸­ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         SquareScreen            â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚    â”‚   (å¯å‚ç›´æ»šåŠ¨å®¹å™¨)    â”‚ â†•    â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚      â”‚
â”‚    â”‚  â”‚   Header      â”‚  â”‚      â”‚
â”‚    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚
â”‚    â”‚  â”‚               â”‚  â”‚      â”‚
â”‚    â”‚  â”‚  KLineChart   â”‚ â†” â† æ°´å¹³æ»šåŠ¨ â”‚
â”‚    â”‚  â”‚ (æ°´å¹³æ»šåŠ¨+ç¼©æ”¾) â”‚  â”‚      â”‚
â”‚    â”‚  â”‚               â”‚  â”‚      â”‚
â”‚    â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚
â”‚    â”‚  â”‚   Footer      â”‚  â”‚      â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚      â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### é‡åˆ°çš„é—®é¢˜

1. **æ»šåŠ¨å¤±æ•ˆ**ï¼šåœ¨ K çº¿å›¾ä¸Šå‚ç›´æ»‘åŠ¨æ—¶ï¼Œæ•´ä¸ªé¡µé¢æ— æ³•æ»šåŠ¨
2. **ç¼©æ”¾åæ›´ä¸¥é‡**ï¼šåŒæŒ‡ç¼©æ”¾ K çº¿åï¼Œå‚ç›´æ»šåŠ¨å®Œå…¨å¤±æ•ˆ
3. **åå­—å…‰æ ‡è¯¯è§¦å‘**ï¼šå‚ç›´æ»‘åŠ¨æ—¶å®¹æ˜“æ„å¤–è§¦å‘åå­—å…‰æ ‡

### ğŸ“Š å¯è§†åŒ–å›¾è§£

![é—®é¢˜åœºæ™¯](assets/é—®é¢˜åœºæ™¯.svg)

---

## é—®é¢˜æ˜¯æ€ä¹ˆå¯¼è‡´çš„

### æ ¹æœ¬åŸå› ï¼šæ‰‹åŠ¿äº‹ä»¶è¢«"åƒæ‰"äº†

```mermaid
flowchart TD
    A["ç”¨æˆ·è§¦æ‘¸å±å¹•"] --> B["è§¦æ‘¸äº‹ä»¶ç”Ÿæˆ"]
    B --> C{"è°å…ˆå¤„ç†?"}
    C -->|"KLineChart çš„ pointerInput"| D["äº‹ä»¶è¢« consume()"]
    C -->|"çˆ¶å®¹å™¨çš„ verticalScroll"| E["é¡µé¢æ»šåŠ¨"]
    D --> F["çˆ¶å®¹å™¨æ”¶ä¸åˆ°äº‹ä»¶!"]
    F --> G["âŒ é¡µé¢æ— æ³•æ»šåŠ¨"]
```

### ä»£ç å±‚é¢çš„é—®é¢˜

```kotlin
// âŒ é—®é¢˜ä»£ç 
.pointerInput(state.mode) {
    awaitEachGesture {
        val down = awaitFirstDown(requireUnconsumed = false)  // æ•è· down äº‹ä»¶
        // ...
        do {
            val event = awaitPointerEvent()
            // å³ä½¿æ˜¯å‚ç›´æ»‘åŠ¨ï¼Œäº‹ä»¶ä¹Ÿè¢«è¿™ä¸ªå¾ªç¯æŒæœ‰
            // çˆ¶å®¹å™¨æ ¹æœ¬æ²¡æœºä¼šå¤„ç†ï¼
        } while (event.changes.any { it.pressed })
    }
}
```

**å…³é”®ç‚¹**ï¼š`awaitFirstDown(requireUnconsumed = false)` ä¼šæ•è·è§¦æ‘¸äº‹ä»¶çš„ "down" é˜¶æ®µã€‚ä¸€æ—¦è¢«æ•è·ï¼Œåç»­çš„ move å’Œ up äº‹ä»¶éƒ½ä¼šåœ¨è¿™ä¸ª `awaitEachGesture` å—ä¸­å¤„ç†ï¼Œçˆ¶å®¹å™¨æ— æ³•æ¥æ”¶å®Œæ•´çš„æ‰‹åŠ¿åºåˆ—ã€‚

---

## åŸç†æ·±åº¦è§£æ

### Compose è§¦æ‘¸äº‹ä»¶ä¼ é€’æœºåˆ¶

```mermaid
flowchart TB
    subgraph "äº‹ä»¶ä¼ é€’æ–¹å‘"
        direction TB
        Touch["è§¦æ‘¸äº‹ä»¶"] --> Initial["PointerEventPass.Initial<br/>(ä»å¤–åˆ°å†…)"]
        Initial --> Main["PointerEventPass.Main<br/>(ä»å†…åˆ°å¤–)"]
        Main --> Final["PointerEventPass.Final<br/>(ä»å¤–åˆ°å†…)"]
    end
    
    subgraph "æ¶ˆè´¹æœºåˆ¶"
        Consume["consume() è°ƒç”¨"] --> Stop["äº‹ä»¶åœæ­¢ä¼ é€’"]
        Stop --> Parent["çˆ¶ç»„ä»¶æ”¶ä¸åˆ°äº‹ä»¶"]
    end
```

### åµŒå¥—æ»šåŠ¨ç³»ç»Ÿ (Nested Scroll System)

Compose æä¾›äº†ä¸“é—¨çš„åµŒå¥—æ»šåŠ¨åè®®æ¥è§£å†³è¿™ç±»å†²çªï¼š

### ğŸ“Š äº‹ä»¶ä¼ é€’ä¸‰é˜¶æ®µå›¾è§£

![äº‹ä»¶ä¼ é€’æœºåˆ¶](assets/äº‹ä»¶ä¼ é€’æœºåˆ¶.svg)

```mermaid
flowchart LR
    subgraph "å­ç»„ä»¶"
        Child["KLineChart"]
        Dispatcher["NestedScrollDispatcher"]
    end
    
    subgraph "çˆ¶ç»„ä»¶"
        Parent["verticalScroll"]
        Connection["NestedScrollConnection"]
    end
    
    Child -->|"1. æ£€æµ‹åˆ°å‚ç›´æ»šåŠ¨"| Dispatcher
    Dispatcher -->|"2. dispatchPreScroll()"| Connection
    Connection -->|"3. çˆ¶ç»„ä»¶å¤„ç†æ»šåŠ¨"| Parent
    Parent -->|"4. è¿”å›æ¶ˆè´¹é‡"| Dispatcher
```

**æ ¸å¿ƒæ¦‚å¿µï¼š**

| ç»„ä»¶ | ä½œç”¨ | ä½¿ç”¨åœºæ™¯ |
|------|------|----------|
| `NestedScrollConnection` | æ¥æ”¶æ¥è‡ªå­ç»„ä»¶çš„æ»šåŠ¨äº‹ä»¶ | çˆ¶ç»„ä»¶å®ç° |
| `NestedScrollDispatcher` | ä¸»åŠ¨å‘çˆ¶ç»„ä»¶å‘é€æ»šåŠ¨äº‹ä»¶ | å­ç»„ä»¶ä½¿ç”¨ |

---

## è§£å†³æ€è·¯

### ç¬¬ä¸€æ­¥ï¼šç†è§£æ–¹å‘é”å®š

å½“ç”¨æˆ·å¼€å§‹æ»‘åŠ¨æ—¶ï¼Œæˆ‘ä»¬éœ€è¦åˆ¤æ–­æ»‘åŠ¨æ–¹å‘ï¼š

```mermaid
flowchart TD
    Start["æ‰‹æŒ‡å¼€å§‹ç§»åŠ¨"] --> Check{"æ£€æµ‹æ»‘åŠ¨æ–¹å‘"}
    Check -->|"abs(deltaX) > abs(deltaY)"| Horizontal["æ°´å¹³æ»‘åŠ¨<br/>â†’ Kçº¿å›¾å¤„ç†"]
    Check -->|"abs(deltaY) > abs(deltaX)"| Vertical["å‚ç›´æ»‘åŠ¨<br/>â†’ çˆ¶å®¹å™¨å¤„ç†"]
    Check -->|"åŒæŒ‡è§¦æ‘¸"| Zoom["ç¼©æ”¾æ‰‹åŠ¿<br/>â†’ Kçº¿å›¾å¤„ç†"]
    
    Horizontal --> ConsumeH["consume() äº‹ä»¶"]
    Vertical --> DispatchV["é€šè¿‡ Dispatcher åˆ†å‘"]
    Zoom --> ConsumeZ["consume() äº‹ä»¶"]
```

### ç¬¬äºŒæ­¥ï¼šä½¿ç”¨ NestedScrollDispatcher

```kotlin
// âœ… æ­£ç¡®æ–¹æ¡ˆ
val nestedScrollDispatcher = remember { NestedScrollDispatcher() }

// åœ¨ Modifier é“¾ä¸­è¿æ¥
modifier
    .nestedScroll(nestedScrollConnection, nestedScrollDispatcher)
    .pointerInput(state.mode) {
        awaitEachGesture {
            // ...
            when (lockedOrientation) {
                1 -> {
                    // æ°´å¹³æ¨¡å¼ï¼šKçº¿å›¾å¤„ç†ï¼Œæ¶ˆè´¹äº‹ä»¶
                    state.scroll(-panDelta.x / scrollUnit)
                    changes.forEach { it.consume() }
                }
                2 -> {
                    // å‚ç›´æ¨¡å¼ï¼šé€šè¿‡ Dispatcher åˆ†å‘ç»™çˆ¶å®¹å™¨
                    val verticalDelta = Offset(0f, panDelta.y)
                    
                    // è¯¢é—®çˆ¶å®¹å™¨æ˜¯å¦è¦é¢„å…ˆæ¶ˆè´¹
                    val preConsumed = nestedScrollDispatcher.dispatchPreScroll(
                        available = verticalDelta,
                        source = NestedScrollSource.Drag
                    )
                    
                    // å‰©ä½™çš„ç»™çˆ¶å®¹å™¨åå¤„ç†
                    nestedScrollDispatcher.dispatchPostScroll(
                        consumed = Offset.Zero,
                        available = verticalDelta - preConsumed,
                        source = NestedScrollSource.Drag
                    )
                    // ä¸æ¶ˆè´¹äº‹ä»¶ï¼
                }
            }
        }
    }
```

### ğŸ“Š è§£å†³æ–¹æ¡ˆå›¾è§£

![è§£å†³æ–¹æ¡ˆ](assets/è§£å†³æ–¹æ¡ˆ.svg)

### ç¬¬ä¸‰æ­¥ï¼šå¤„ç†é•¿æŒ‰æ‰‹åŠ¿å†²çª

```mermaid
flowchart TD
    subgraph "é—®é¢˜"
        P1["å‚ç›´æ»‘åŠ¨æ—¶"] --> P2["æ‰‹æŒ‡åœç•™è¶…è¿‡é•¿æŒ‰é˜ˆå€¼"]
        P2 --> P3["åå­—å…‰æ ‡è¢«è§¦å‘ âŒ"]
    end
    
    subgraph "è§£å†³æ–¹æ¡ˆ"
        S1["è°ƒæ•´ pointerInput é¡ºåº"] --> S2["ç»Ÿä¸€æ‰‹åŠ¿å¤„ç†å™¨å…ˆæ‰§è¡Œ"]
        S2 --> S3["æ£€æµ‹åˆ°æ»‘åŠ¨ â†’ æ¶ˆè´¹äº‹ä»¶"]
        S3 --> S4["é•¿æŒ‰æ£€æµ‹è¢«å–æ¶ˆ âœ…"]
    end
```

---

## æœ€ä½³å®è·µæ ‡å‡†

### 1. Modifier é“¾çš„æ­£ç¡®é¡ºåº

```kotlin
Canvas(
    modifier = Modifier
        // 1ï¸âƒ£ é¦–å…ˆï¼šåµŒå¥—æ»šåŠ¨è¿æ¥
        .nestedScroll(connection, dispatcher)
        
        // 2ï¸âƒ£ å…¶æ¬¡ï¼šç®€å•æ‰‹åŠ¿ï¼ˆç‚¹å‡»ã€é•¿æŒ‰ï¼‰
        .pointerInput(key) { detectTapGestures { ... } }
        .pointerInput(key) { detectDragGesturesAfterLongPress { ... } }
        
        // 3ï¸âƒ£ æœ€åï¼šå¤æ‚æ‰‹åŠ¿ï¼ˆæ»šåŠ¨ã€ç¼©æ”¾ï¼‰
        .pointerInput(key) { 
            awaitEachGesture { ... }
        }
)
```

### ğŸ“Š æœ€ä½³å®è·µå›¾è§£

![æœ€ä½³å®è·µ](assets/æœ€ä½³å®è·µ.svg)

### 2. æ–¹å‘é”å®šæ¨¡å¼

```kotlin
// æ–¹å‘é”å®šçŠ¶æ€æœº
var lockedOrientation = 0  // 0=æœªå®š, 1=æ°´å¹³, 2=å‚ç›´

// æ–¹å‘æ£€æµ‹
if (lockedOrientation == 0) {
    accumulatedPan += panDelta
    
    if (abs(accumulatedPan.x) > touchSlop || abs(accumulatedPan.y) > touchSlop) {
        lockedOrientation = if (abs(accumulatedPan.x) > abs(accumulatedPan.y)) {
            1  // æ°´å¹³ â†’ è‡ªå·±å¤„ç†
        } else {
            2  // å‚ç›´ â†’ åˆ†å‘ç»™çˆ¶å®¹å™¨
        }
    }
}
```

### 3. äº‹ä»¶æ¶ˆè´¹åŸåˆ™

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    äº‹ä»¶æ¶ˆè´¹å†³ç­–æ ‘                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚   Q: è¿™ä¸ªäº‹ä»¶æˆ‘éœ€è¦å¤„ç†å—ï¼Ÿ                              â”‚
â”‚                                                         â”‚
â”‚   â”œâ”€â”€ æ˜¯ â†’ consume() å¹¶å¤„ç†                             â”‚
â”‚   â”‚                                                     â”‚
â”‚   â””â”€â”€ å¦ â†’ ä¸¤ç§é€‰æ‹©ï¼š                                   â”‚
â”‚       â”‚                                                 â”‚
â”‚       â”œâ”€â”€ ç®€å•åœºæ™¯ï¼šä¸è°ƒç”¨ consume()ï¼Œè®©äº‹ä»¶ç»§ç»­ä¼ é€’      â”‚
â”‚       â”‚                                                 â”‚
â”‚       â””â”€â”€ å¤æ‚åœºæ™¯ï¼šä½¿ç”¨ NestedScrollDispatcher        â”‚
â”‚           ä¸»åŠ¨åˆ†å‘ç»™çˆ¶å®¹å™¨                               â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. æŠ¬èµ·æ‰‹æŒ‡çš„å¤„ç†

```kotlin
fun onRelease() {
    // âœ… æ€»æ˜¯æ¸…ç†çŠ¶æ€
    if (mode == ChartMode.CROSSHAIR) {
        mode = ChartMode.SCROLLING
        crosshairIndex = -1
    }
}
```

---

## é‡åˆ°ç±»ä¼¼é—®é¢˜çš„æ’æŸ¥æŒ‡å—

### ğŸ” è¯Šæ–­æ¸…å•

```
â–¡ 1. ç¡®è®¤é—®é¢˜ç°è±¡
    - å“ªä¸ªæ–¹å‘çš„æ»šåŠ¨å¤±æ•ˆï¼Ÿ
    - ä»€ä¹ˆæ“ä½œåå¤±æ•ˆï¼Ÿï¼ˆç¼©æ”¾ï¼Ÿé•¿æŒ‰ï¼Ÿï¼‰
    - æ˜¯å®Œå…¨å¤±æ•ˆè¿˜æ˜¯å¶å‘ï¼Ÿ

â–¡ 2. æ£€æŸ¥ Modifier é“¾
    - pointerInput çš„é¡ºåºæ˜¯å¦æ­£ç¡®ï¼Ÿ
    - æ˜¯å¦ä½¿ç”¨äº† nestedScrollï¼Ÿ
    - key å‚æ•°æ˜¯å¦ä¼šå¯¼è‡´æ„å¤–é‡å»ºï¼Ÿ

â–¡ 3. æ£€æŸ¥äº‹ä»¶æ¶ˆè´¹
    - æ˜¯å¦æœ‰ä¸å¿…è¦çš„ consume() è°ƒç”¨ï¼Ÿ
    - consume() çš„æ¡ä»¶æ˜¯å¦æ­£ç¡®ï¼Ÿ

â–¡ 4. æ£€æŸ¥æ‰‹åŠ¿æ£€æµ‹å™¨
    - awaitFirstDown çš„ requireUnconsumed å‚æ•°ï¼Ÿ
    - æ˜¯å¦æœ‰å¤šä¸ªæ‰‹åŠ¿æ£€æµ‹å™¨ç«äº‰ï¼Ÿ
```

### ğŸ› ï¸ å¸¸è§é—®é¢˜é€ŸæŸ¥

| ç—‡çŠ¶ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| åµŒå¥—æ»šåŠ¨å®Œå…¨å¤±æ•ˆ | pointerInput consume æ‰€æœ‰äº‹ä»¶ | ä½¿ç”¨ NestedScrollDispatcher |
| ç¼©æ”¾åæ»šåŠ¨å¤±æ•ˆ | æ–¹å‘é”å®šæœªæ­£ç¡®é‡ç½® | æ¯æ¬¡ awaitEachGesture é‡ç½®çŠ¶æ€ |
| é•¿æŒ‰è¯¯è§¦å‘ | æ‰‹åŠ¿æ£€æµ‹å™¨é¡ºåºé—®é¢˜ | è°ƒæ•´ pointerInput é¡ºåº |
| æ»šåŠ¨ä¸æµç•… | äº‹ä»¶å¤„ç†é˜»å¡ | ä¼˜åŒ–æ–¹å‘æ£€æµ‹é€»è¾‘ |

### ğŸ“ æ¶æ„å†³ç­–æµç¨‹

```mermaid
flowchart TD
    Start["éœ€è¦è‡ªå®šä¹‰æ‰‹åŠ¿?"] -->|æ˜¯| A["ä½¿ç”¨ pointerInput"]
    Start -->|å¦| B["ä½¿ç”¨å†…ç½® Modifier<br/>(scrollable, draggable)"]
    
    A --> C{"ä¼šåµŒå¥—åœ¨æ»šåŠ¨å®¹å™¨ä¸­?"}
    C -->|æ˜¯| D["å¿…é¡»å®ç°åµŒå¥—æ»šåŠ¨åè®®"]
    C -->|å¦| E["ç›´æ¥å¤„ç†äº‹ä»¶"]
    
    D --> F["1. åˆ›å»º NestedScrollDispatcher"]
    F --> G["2. è¿æ¥ nestedScroll modifier"]
    G --> H["3. æ–¹å‘æ£€æµ‹ååˆ†å‘æˆ–æ¶ˆè´¹"]
    
    B --> I["è‡ªåŠ¨å‚ä¸åµŒå¥—æ»šåŠ¨ âœ…"]
```

---

## ğŸ’¡ æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **ç†è§£äº‹ä»¶æµ**ï¼šè§¦æ‘¸äº‹ä»¶ä»å¤–åˆ°å†…ä¼ é€’ï¼Œconsume() ä¼šé˜»æ­¢ç»§ç»­ä¼ é€’
2. **å–„ç”¨åµŒå¥—æ»šåŠ¨**ï¼š`NestedScrollDispatcher` æ˜¯è§£å†³å†²çªçš„æ­£ç¡®å·¥å…·
3. **æ–¹å‘é”å®š**ï¼šä¸€æ—¦ç¡®å®šæ»‘åŠ¨æ–¹å‘ï¼Œå°±é”å®šå¹¶ä¸€è‡´å¤„ç†
4. **æ¸…ç†çŠ¶æ€**ï¼šæ‰‹æŒ‡æŠ¬èµ·æ—¶åŠ¡å¿…é‡ç½®æ‰€æœ‰çŠ¶æ€
5. **Modifier é¡ºåº**ï¼šnestedScroll åœ¨å‰ï¼Œå¤æ‚æ‰‹åŠ¿åœ¨å

### å…³é”®ä»£ç æ¨¡å¼

```kotlin
// åµŒå¥—æ»šåŠ¨ç»„ä»¶çš„æ ‡å‡†æ¨¡æ¿
@Composable
fun NestedScrollableComponent(modifier: Modifier = Modifier) {
    val dispatcher = remember { NestedScrollDispatcher() }
    val connection = remember { object : NestedScrollConnection { ... } }
    
    Box(
        modifier = modifier
            .nestedScroll(connection, dispatcher)
            .pointerInput(Unit) {
                awaitEachGesture {
                    var orientation = 0
                    val down = awaitFirstDown()
                    
                    do {
                        val event = awaitPointerEvent()
                        val delta = event.calculatePan()
                        
                        // æ–¹å‘æ£€æµ‹
                        if (orientation == 0 && delta.getDistance() > touchSlop) {
                            orientation = if (abs(delta.x) > abs(delta.y)) 1 else 2
                        }
                        
                        when (orientation) {
                            1 -> handleHorizontal(delta, event.changes)
                            2 -> dispatchToParent(dispatcher, delta)
                        }
                    } while (event.changes.any { it.pressed })
                }
            }
    )
}
```

---

> ğŸ“š **å»¶ä¼¸é˜…è¯»**
> - [Compose å®˜æ–¹åµŒå¥—æ»šåŠ¨æ–‡æ¡£](https://developer.android.com/develop/ui/compose/touch-input/pointer-input/scroll)
> - [PointerInput æ·±åº¦è§£æ](https://developer.android.com/develop/ui/compose/touch-input/pointer-input/understand-gestures)
