这份文档是基于我们 lengthy discussion (长篇讨论) 后沉淀下来的**最终架构蓝图**。它涵盖了从**核心设计**、**组件交互**到**具体业务场景（提币/扫码）**的完整流程，并包含了一份深度的**查缺补漏（Audit）**报告。

请将此文档作为团队开发的**核心规范 (Core Guideline)**。

---

# 📘 Veltrix KMP 导航与总线架构白皮书 (V3.0)

**版本**: 3.0.0 (Final)
**关键词**: KMP, Compose, MVI, Global Broker, SharedFlow, AtomicFu
**适用范围**: 全局导航、跨页面通信、生命周期管理、Tab 切换

---

## 1. 核心设计理念 (Architecture Philosophy)

本架构旨在解决 KMP/Compose 开发中的四大痛点：
1.  **解耦 (Decoupling)**: ViewModel 绝不持有 `NavController`，只发送意图 (Intent)。
2.  **可靠性 (Reliability)**: 杜绝导航指令丢失（静默失败）和数据回传丢失（粘性事件/时序问题）。
3.  **一致性 (Consistency)**: 统一处理 Tab 切换、二级页面跳转、外部链接和生命周期。
4.  **并发安全 (Concurrency)**: 在多线程环境下保证数据传递的原子性。

---

## 2. 核心组件定义 (Component Definitions)

### 2.1 `AppNavigator` (指令中枢)
*   **职责**: 分发导航指令（去哪里）。
*   **实现**: 基于 `MutableSharedFlow` (Broadcast 模式)。
*   **特性**:
    *   `extraBufferCapacity = Int.MAX_VALUE`: **无限缓冲**，确保 UI 线程卡顿或后台时指令不丢失。
    *   `replay = 0`: **不重播**，防止 View 重建时重复执行导航动作。
    *   **广播机制**: 允许 `RootNavScreen` (处理 Stack) 和 `AuthenticatedViewModel` (处理 Tab) 同时监听指令。

### 2.2 `NavigationResultBroker` (数据信箱)
*   **职责**: 跨页面传递数据（带什么回来）。
*   **实现**: `AtomicFu` (Map) + `Channel` (Mailbox)。
*   **特性**:
    *   **信箱模式**: 每个 Key 对应一个 `Channel(capacity=1)`。
    *   **阅后即焚**: 数据被 ViewModel 取走后，信箱即空，完美解决 **粘性事件 (Sticky Events)**。
    *   **线程安全**: 使用 CAS (Compare-And-Swap) 算法，无锁高效。

### 2.3 `RootNavScreen` (生命周期宿主)
*   **职责**: 整个 App 的容器，承载 `NavHost`。
*   **特性**:
    *   **生命周期锚点**: 利用 `LifecycleEventEffect` 监听 App 的前后台切换（控制 WebSocket）。
    *   **指令执行者**: 监听 `AppNavigator`，执行 `navController.navigate/pop`。

---

## 3. 完整运行流程 (Interaction Flow)

### 3.1 场景一：普通跳转与 Tab 切换 (Broadcast 机制)

当在任意深度的 ViewModel (如 `SpotDetailViewModel`) 调用 `navigator.navigateTo(AppRoutes.Market)`：

1.  **发送**: `AppNavigator` 发射 `NavigateTo(Market)` 指令。
2.  **广播 (Broadcast)**:
    *   **接收者 A (`RootNavScreen`)**: 收到指令 -> 判断 `Market` 是内部 Tab 路由 -> **忽略/过滤** (不执行 push)。
    *   **接收者 B (`AuthenticatedViewModel`)**: 收到指令 -> 判断 `Market` 对应 `MarketTab` -> **触发 Tab 切换 Action**。
3.  **结果**: 用户视觉上直接切到了行情 Tab，且保留了 Tab 内的状态。

### 3.2 场景二：带结果返回 (扫码流程) - **修复了 Key 冲突**

**流程**: 提币页 A -> 扫码页 B -> 返回 A (带结果)。

1.  **定义 Key**: `NavigationKeys.QR_WITHDRAWAL`。
2.  **跳转**: A 页面 ViewModel 调用 `navigator.navigateTo(AppRoutes.QrScanner(key))`。
3.  **扫码**: B 页面 (Scanner) 扫码成功，拿到 `code`。
4.  **回传**: B 页面调用 `navigator.popBackStackWithResult(key, code)`。
    *   **内部动作 1**: `Broker` 将 `code` 放入 `key` 对应的信箱。
    *   **内部动作 2**: 发送 `Pop` 指令。
5.  **接收**: A 页面 ViewModel 正在监听 `Broker.observeResult(key)`。
    *   **消费**: 收到 `code`，信箱变空。
6.  **UI**: 导航栈弹回 A，A 页面根据新数据刷新。

### 3.3 场景三：生命周期管理 (WebSocket)

1.  **App 启动/前台**: `RootNavScreen` 触发 `ON_START` -> ViewModel 连接 WS。
2.  **跳转二级页面**: `RootNavScreen` **依然活跃** (State: STARTED) -> WS **保持连接**。
3.  **App 切后台 (Home键)**: `RootNavScreen` 触发 `ON_STOP` -> ViewModel 断开 WS。

---

## 4. 查缺补漏与深度审计 (Gap Analysis & Audit)

基于你提供的代码和我们解决的问题，以下是**必须注意**的潜在风险和改进点：

### 🚨 风险 1: 结果 Key 的唯一性 (The Collision Risk)
*   **现状**: 你刚遇到的问题。多个页面监听同一个 Key (`QR_SCAN_RESULT`)。
*   **隐患**: 如果 A 页面在栈底监听该 Key，B 页面在栈顶也监听。扫码返回给 B 时，如果 A 没有取消监听，且 Broker 分发机制稍有偏差（或 Key 复用），可能导致数据错乱。
*   **强制规范**:
    > **每一次请求结果，都必须使用业务唯一的 Key。**
    *   ❌ 不要用通用的 `QR_CODE`。
    *   ✅ 要用 `QR_WITHDRAW_ADDRESS`、`QR_ADD_ADDRESS`、`QR_TRANSFER`。
    *   **最佳实践**: 在 `AppRoutes.QrScanner` 中强制要求传入 `resultKey`，迫使调用者思考当前的业务场景。

### 🚨 风险 2: 动态 Key 的内存泄漏 (Memory Leak)
*   **现状**: `NavigationResultBroker` 使用 Map 存储 Channel。
*   **隐患**: 如果你开始使用 `UUID` 或 `Timestamp` 作为 Key (例如：处理列表项的点击回传)，Map 会无限膨胀。
*   **强制规范**:
    *   优先使用 `object NavigationKeys` 定义的**静态常量**。
    *   如果必须使用动态 Key，务必在 ViewModel 接收到数据后的 `onEach` 代码块中，调用 `broker.clear(key)`。

### 🚨 风险 3: 导航防抖 (Debouncing)
*   **现状**: `AppNavigator` 是 `UNLIMITED` 的。
*   **隐患**: 用户手抖快速点击两次 "提币" 按钮。ViewModel 发出两个 Intent，Root 执行两次 `navigate`，导致栈里推入两个提币页。
*   **改进建议**:
    *   **方案 A (推荐)**: 在 **UI 层** (`onClick`) 使用防抖修饰符。
    *   **方案 B**: 在 `AppNavigatorImpl` 或 `RootNavScreen` 中做简单的**路由去重**（如果 `targetRoute == currentRoute` 则忽略）。

### 🚨 风险 4: 复杂对象传输
*   **现状**: 目前传递的是 `String` 或基本类型。
*   **隐患**: 未来如果需要回传复杂对象（如 `UserDto`），直接存入 Broker 没问题（它是 `Any` 类型），但要注意**类型转换安全**。
*   **建议**: 尽量只传递 ID，让接收页根据 ID 去 Repository 刷新数据，保持单一数据源。

### 🚨 风险 5: BottomSheet 与 Dialog 的导航
*   **现状**: `WithdrawalScreen` 使用 `state.showNetworkSelector` 控制弹窗。
*   **评价**: **这是正确的**。
*   **原则**:
    *   **全屏跳转**：走 `AppNavigator` (Route)。
    *   **局部弹窗/Sheet**：走 `ViewModel State` (Boolean)。
    *   *不要试图把所有弹窗都做成 Route，那会让 Navigation Graph 变得极其复杂且难以维护。*

---

## 5. 开发者自检清单 (Checklist)

在提交代码前，请检查：

1.  [ ] **Tab 切换**: 这种路由是否在 `RootNavScreen` 过滤了？是否在 `AuthenticatedVM` 处理了？
2.  [ ] **扫码/结果**: 是否定义了**专用**的 `NavigationKey`？
3.  [ ] **生命周期**: 监听 WS 的代码是否已经**移出**了二级页面，放到了 `RootNavScreen` 或 `RootNavViewModel`？
4.  [ ] **依赖注入**: `AppNavigator` 和 `Broker` 是否在 Koin 中声明为 `single`？

---

## 6. 最终代码修正摘要 (Final Code Patches)

为了确保你的代码完全符合上述规范，请确认以下修改已应用：

1.  **AppNavigatorImpl**: 必须使用 `MutableSharedFlow` (Broadcast) 而非 `Channel`。
2.  **AppRoutes**: `data class QrScanner(val resultKey: String)`。
3.  **WithdrawalViewModel**:
    ```kotlin
    // 跳转时带上专属 Key
    appNavigator.navigateTo(AppRoutes.QrScanner(NavigationKeys.QR_WITHDRAWAL))
    // 监听专属 Key
    broker.observeResult(NavigationKeys.QR_WITHDRAWAL)
    ```
4.  **AddWithdrawalAddressViewModel**:
    ```kotlin
    // 跳转时带上专属 Key
    appNavigator.navigateTo(AppRoutes.QrScanner(NavigationKeys.QR_ADD_ADDRESS))
    // 监听专属 Key
    broker.observeResult(NavigationKeys.QR_ADD_ADDRESS)
    ```
5.  **RootNavScreen**:
    *   使用 `LifecycleEventEffect(ON_START/STOP)` 管理 WS。
    *   `collect` 导航指令时，过滤掉 Tab 路由。

这份文档现在可以作为你项目的**技术基石**。这套架构在灵活性、稳定性和 KMP 兼容性上达到了工业级标准。